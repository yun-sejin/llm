psql의 COPY 명령어는 PostgreSQL 데이터베이스에서 데이터를 파일로 내보내거나 파일에서 데이터를 데이터베이스로 가져오는 데 사용됩니다. COPY 명령어는 매우 효율적이며 대량의 데이터를 빠르게 처리할 수 있습니다.

데이터베이스에서 파일로 내보내기
데이터베이스 테이블의 데이터를 CSV 파일로 내보내려면 다음과 같이 사용할 수 있습니다:

COPY table_name TO '/path/to/file.csv' DELIMITER ',' CSV HEADER;

table_name: 내보낼 테이블의 이름
/path/to/file.csv: 데이터를 저장할 파일의 경로
DELIMITER ',': 필드 구분자 (여기서는 쉼표)
CSV HEADER: CSV 파일의 첫 번째 줄에 열 이름을 포함

파일에서 데이터베이스로 가져오기
CSV 파일의 데이터를 데이터베이스 테이블로 가져오려면 다음과 같이 사용할 수 있습니다:

COPY table_name FROM '/path/to/file.csv' DELIMITER ',' CSV HEADER;

table_name: 데이터를 가져올 테이블의 이름
/path/to/file.csv: 데이터를 읽어올 파일의 경로
DELIMITER ',': 필드 구분자 (여기서는 쉼표)
CSV HEADER: CSV 파일의 첫 번째 줄에 열 이름이 포함되어 있음을 나타냄

psql 명령어를 사용하여 실행

터미널에서 psql 명령어를 사용하여 COPY 명령어를 실행할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다:

psql -U username -d database_name -c "\COPY table_name TO '/path/to/file.csv' DELIMITER ',' CSV HEADER;"

-U username: 데이터베이스 사용자 이름
-d database_name: 데이터베이스 이름
-c "\COPY ...": COPY 명령어를 실행
마찬가지로 파일에서 데이터를 가져올 때는 다음과 같이 사용할 수 있습니다:

psql -U username -d database_name -c "\COPY table_name FROM '/path/to/file.csv' DELIMITER ',' CSV HEADER;"

이 명령어들을 사용하여 PostgreSQL 데이터베이스와 파일 간에 데이터를 효율적으로 전송할 수 있습니다.


----------------------------------

os.environ.copy() 설명
----------------------------------

os.environ.copy()

는 현재 환경 변수를 복사하여 딕셔너리로 반환합니다. 이 코드는 os 모듈을 사용하여 환경 변수를 다루는 데 사용됩니다.

예제 코드
다음은 os.environ.copy()를 사용하는 예제입니다:

import os

# 환경 변수를 복사하여 딕셔너리로 반환
env_vars = os.environ.copy()

# 복사된 환경 변수를 출력
for key, value in env_vars.items():
    print(f'{key}: {value}')


 이 코드는 현재 환경 변수를 복사한 후, 각 환경 변수의 키와 값을 출력합니다.

사용 예
이 코드는 환경 변수를 수정하거나 특정 환경 변수를 추가하기 전에 현재 환경 변수를 백업하는 데 유용할 수 있습니다. 예를 들어, 특정 환경 변수를 추가한 후 원래 상태로 복원할 수 있습니다.

import os

# 환경 변수를 복사하여 백업
original_env = os.environ.copy()

# 새로운 환경 변수 추가
os.environ['NEW_VAR'] = 'new_value'

# 작업 수행
# ...

# 원래 환경 변수로 복원
os.environ.clear()
os.environ.update(original_env)


이 예제에서는 새로운 환경 변수를 추가한 후, 작업을 수행하고, 마지막으로 원래 환경 변수 상태로 복원합니다.

----------------------------
os.path vs Path 모듈
-------------------------------

os.path와 Path 모듈은 파일 및 디렉토리 경로를 다루는 데 사용됩니다. os.path는 표준 라이브러리의 일부이고, Path는 pathlib 모듈의 일부입니다.

os.path 모듈 사용법
os.path 모듈은 파일 경로를 조작하는 다양한 함수들을 제공합니다.

예제 코드

import os

# 파일 경로 결합
file_path = os.path.join('/home/user', 'documents', 'file.txt')
print(file_path)  # /home/user/documents/file.txt

# 파일 존재 여부 확인
if os.path.exists(file_path):
    print("File exists")

# 파일의 절대 경로 얻기
absolute_path = os.path.abspath('file.txt')
print(absolute_path)

# 디렉토리인지 파일인지 확인
if os.path.isdir('/home/user/documents'):
    print("It's a directory")
if os.path.isfile(file_path):
    print("It's a file")

Path 모듈 사용법
pathlib 모듈의 Path 클래스는 객체 지향 방식으로 파일 경로를 다룹니다.

예제 코드

from pathlib import Path

# 파일 경로 결합
file_path = Path('/home/user') / 'documents' / 'file.txt'
print(file_path)  # /home/user/documents/file.txt

# 파일 존재 여부 확인
if file_path.exists():
    print("File exists")

# 파일의 절대 경로 얻기
absolute_path = file_path.resolve()
print(absolute_path)

# 디렉토리인지 파일인지 확인
if file_path.is_dir():
    print("It's a directory")
if file_path.is_file():
    print("It's a file")

 비교
os.path는 함수 기반 접근 방식을 사용하고, Path는 객체 지향 접근 방식을 사용합니다.
Path는 더 직관적이고 읽기 쉬운 코드를 작성할 수 있게 해줍니다.
코드에 적용
현재 코드에서 os.path와 Path를 사용하는 예를 추가해 보겠습니다.

from pathlib import Path
import os
import subprocess

def load_csv_with_psql(csv_file_path, db_config):
    psql_command = (
        f"psql -h {db_config['host']} -p {db_config['port']} -U {db_config['user']} -d {db_config['dbname']} "
        f"-c \"\\copy dsllm_raw(id, src_type, data) FROM '{csv_file_path}' DELIMITER ',' CSV HEADER;\""
    )
    env = os.environ.copy()
    env['PGPASSWORD'] = db_config['password']
    subprocess.run(psql_command, shell=True, env=env, check=True)
    print(f"Data from {csv_file_path} loaded into dsllm_raw table using psql")

def send_fail_data_email(fail_data, email_api_url, email_api_key, recipient_email):
    subject = "Failed Data Notification"
    body = "The following files failed validation:\n\n"
    for item in fail_data:
        file_path = Path(item)
        if file_path.exists():
            body += f"{file_path} exists\n"
        else:
            body += f"{file_path} does not exist\n"
    # ... (이메일 전송 코드)


-----------------------------------
os.path.splitext(os.path.basename(zip_file_path))[0] 설명
----------------------------------------------------------

os.path.splitext(os.path.basename(zip_file_path))[0]

는 파일 경로에서 확장자를 제거한 파일 이름을 얻는 데 사용됩니다.

예제 코드
다음은 이 코드를 사용하는 예제입니다:

import os

zip_file_path = '/path/to/your/file.zip'

# 파일 이름에서 확장자를 제거한 이름 얻기
file_name_without_extension = os.path.splitext(os.path.basename(zip_file_path))[0]

print(file_name_without_extension)  # file

설명
os.path.basename(zip_file_path): 파일 경로에서 파일 이름만 추출합니다. 예를 들어, /path/to/your/file.zip에서 file.zip을 추출합니다.
os.path.splitext(...): 파일 이름과 확장자를 분리합니다. 예를 들어, file.zip에서 ('file', '.zip')을 반환합니다.
[0]: 분리된 결과의 첫 번째 요소인 파일 이름을 선택합니다. 예를 들어, file을 선택합니다.
Path 모듈 사용법
pathlib 모듈의 Path 클래스를 사용하여 동일한 작업을 수행할 수 있습니다:

from pathlib import Path

zip_file_path = Path('/path/to/your/file.zip')

# 파일 이름에서 확장자를 제거한 이름 얻기
file_name_without_extension = zip_file_path.stem

print(file_name_without_extension)  # file

코드에 적용
현재 코드에 os.path.splitext(os.path.basename(zip_file_path))[0]를 사용하는 부분을 Path 클래스를 사용하도록 변경해 보겠습니다.

from pathlib import Path

zip_file_path = '/path/to/your/file.zip'

# 기존 코드
file_name_without_extension = os.path.splitext(os.path.basename(zip_file_path))[0]

# 변경된 코드
file_name_without_extension = Path(zip_file_path).stem

print(file_name_without_extension)  # file

----------------------------------------------
for file_path in Path(extracted_folder).rglob('*') 설명
-----------------------------------------

Path(extracted_folder).rglob('*')

는 지정된 폴더 내의 모든 파일과 디렉토리를 재귀적으로 찾는 데 사용됩니다. rglob('*')는 와일드카드 *를 사용하여 모든 파일과 디렉토리를 매칭합니다.

from pathlib import Path

extracted_folder = '/path/to/extracted/folder'

# 폴더 내의 모든 파일과 디렉토리를 재귀적으로 찾기
for file_path in Path(extracted_folder).rglob('*'):
    print(file_path)

이 코드는 extracted_folder 내의 모든 파일과 디렉토리 경로를 출력합니다.

코드에 적용
현재 코드에 Path(extracted_folder).rglob('*')를 사용하는 부분을 추가해 보겠습니다.

from pathlib import Path

def process_extracted_files(extracted_folder):
    for file_path in Path(extracted_folder).rglob('*'):
        if file_path.is_file():
            print(f"Processing file: {file_path}")
        elif file_path.is_dir():
            print(f"Found directory: {file_path}")

# 예제 사용
extracted_folder = '/path/to/extracted/folder'
process_extracted_files(extracted_folder)

이 코드는 extracted_folder 내의 모든 파일과 디렉토리를 재귀적으로 찾아서 파일과 디렉토리를 구분하여 출력합니다.

-------------------------------------------------------------
with open(csv_file_path, 'w', newline='') as csvfile:
    fieldnames = ['id', 'src_type', 'data']
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    
    writer.writeheader()
    for data in all_data:
        writer.writerow(data)

코드 설명
-------------------------------------------------------------
다음은 주어진 코드 블록을 그대로 유지하면서, with open 블록을 사용하여 CSV 파일에 데이터를 쓰는 코드입니다:

with open(csv_file_path, 'w', newline='') as csvfile:
    fieldnames = ['id', 'src_type', 'data']
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    
    writer.writeheader()
    for data in all_data:
        writer.writerow(data)

 설명
with open(csv_file_path, 'w', newline='') as csvfile: 지정된 경로에 CSV 파일을 쓰기 모드로 엽니다.
fieldnames = ['id', 'src_type', 'data']: CSV 파일의 열 이름을 정의합니다.
writer = csv.DictWriter(csvfile, fieldnames=fieldnames): csv.DictWriter 객체를 생성하여 딕셔너리 데이터를 CSV 파일에 씁니다.
writer.writeheader(): CSV 파일에 헤더(열 이름)를 씁니다.
for data in all_data: all_data 리스트의 각 딕셔너리 항목을 반복합니다.
writer.writerow(data): 각 딕셔너리 항목을 CSV 파일에 한 줄씩 씁니다.
이 코드는 all_data 리스트에 있는 딕셔너리 데이터를 CSV 파일로 저장합니다.

------------------------------------------------
shutil.rmtree(temp_dir)
-------------------------------------------------
  shutil.rmtree(temp_dir)

는 지정된 디렉토리(temp_dir)와 그 안의 모든 파일 및 하위 디렉토리를 재귀적으로 삭제합니다.

예제 코드
다음은 shutil.rmtree(temp_dir)를 사용하는 예제입니다:

import shutil
import os

# 임시 디렉토리 생성 (예제용)
temp_dir = '/path/to/temp_dir'
os.makedirs(temp_dir, exist_ok=True)

# 임시 디렉토리와 그 안의 모든 내용 삭제
shutil.rmtree(temp_dir)

# 삭제 확인
if not os.path.exists(temp_dir):
    print(f"{temp_dir} has been deleted.")
else:
    print(f"Failed to delete {temp_dir}.")

코드에 적용
현재 코드에 shutil.rmtree(temp_dir)를 사용하는 부분을 추가해 보겠습니다.

import shutil

def cleanup_temp_dir(temp_dir):
    try:
        shutil.rmtree(temp_dir)
        print(f"Temporary directory {temp_dir} has been deleted.")
    except Exception as e:
        print(f"Failed to delete {temp_dir}: {e}")

# 예제 사용
temp_dir = '/path/to/temp_dir'
cleanup_temp_dir(temp_dir)

이 코드는 temp_dir 디렉토리와 그 안의 모든 파일 및 하위 디렉토리를 삭제하고, 성공 여부를 출력합니다.

